<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LAN File Sharing</title>
  <style>
   * {
    box-sizing: border-box;
   }

   body {
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f4f4f4;
   }

   h2,
   h3 {
    text-align: center;
   }

   .container {
    max-width: 500px;
    margin: auto;
    padding: 15px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
   }

   input[type="text"],
   input[type="file"] {
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    font-size: 16px;
    border-radius: 5px;
    border: 1px solid #ccc;
   }

   #roomDisplay,
   #connectedDisplay {
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
   }

   button {
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    font-size: 16px;
    border-radius: 5px;
    color: white;
    border: none;
    cursor: pointer;
   }

   .card {
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    background: #fff;
   }

   .progress {
    width: 100%;
    height: 15px;
    background: #eee;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
   }

   .bar {
    height: 100%;
    width: 10%;
    background: #4caf50;
    transition: width 0.3s;
   }

   #sendBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #4caf50;
   }

   #cancelBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #f44336;
   }

   #downloadBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #2196f3;
   }

   .bg-success {
    background-color: #4caf50;
   }

   .bg-error {
    background-color: #f44336;
   }

   .bg-info {
    background-color: #2196f3;
   }

   .success {
    color: #4caf50;
   }

   .error {
    color: #f44336;
   }

   .info {
    color: #2196f3;
   }
  </style>
 </head>
 <body>
  <div class="container">
   <h2>P2P File Sharing</h2>
   <div> Room ID : <span id="roomId">----</span>
    <!-- this will display Room Id -->
   </div>
   <div> Connected Devices : <span id="connectedDevice">0</span>
    <!-- this will display connected device counts including the host -->
   </div>
   <input type="text" id="roomIdinput" placeholder="Enter Room Code (4-digit) to Host / Join" maxlength="4" />
   <!-- input to enter 4 digit room code to join, first user will be the host-->
   <button id="joinBtn" class="bg-info">Join Room</button>
   <!-- this will change to "Exit Room" with bg-error, once the user is joined in room-->
   <input type="file" id="fileInput" />
   <!-- this will select the file to send -->
   <button id="sendBtn" onclick="sendFile()">Send</button>
   <!-- this will start sending the file -->
   <div id="sendFilesDisplay">
    <!-- sending files will be displayed here -->
    <h3>Send Files</h3>
    <div class="card">
     <p>
      <strong>file.name</strong>
      <!-- file name will be displayed here -->
     </p>
     <p>real-time.file.sizes</p>
     <!-- real time file size transfer will be displayed here -->
     <div class="progress">
      <!-- real time progress bar, hides after transfer is completed/cancelled -->
      <div class="bar" id="sendProgressbar"></div>
     </div>
     <button id="cancelBtn" class="bg-error">Cancel</button>
     <!-- this button will cancel sending files, hides after transfer is completed/cancelled -->
     <p class="success">File Sent</p>
     <!-- this will be displayed, if transfer is succces -->
     <p class="error">Transfer Error</p>
     <!-- this will be displayed, if transfer is not success -->
     <p class="error">Transfer Cancelled</p>
     <!-- this will be displayed, if transfer is canceled  -->
    </div>
   </div>
   <div id="receivedFilesDisplay">
   <!-- Received files will be displayed here -->
    <h3>Received Files</h3>
    <div class="card">
     <p>
      <strong>file.name</strong>
      <!-- file name will be displayed here -->
     </p>
     <p>real-time.file.sizes</p>
     <!-- real time file size transfer will be displayed here -->
     <div class="progress">
     <!-- real time progress bar, hides after transfer is completed/cancelled -->
      <div class="bar" id="receiveProgressbar"></div>
     </div>
     <button id="cancelBtn" class="bg-error">Cancel</button>
     <!-- this button will cancel receiving files, hides after transfer is completed/cancelled -->
     <p class="success">File Recieved</p>
     <!-- this will be displayed, if transfer is succces -->
     <p class="error">Transfer Error</p>
     <!-- this will be displayed, if transfer is not success -->
     <p class="error">Transfer Cancelled</p>
     <!-- this will be displayed, if transfer is canceled  -->
     <button id="downloadBtn">Download</button>
     <!-- this button will download the received file, show on when the file is reccieved -->
    </div>
   </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let peerConnections = {};
    let roomId;
    let localStream;
    let fileReader;
    let sendingFile;
    let sendingChannel;

    const joinBtn = document.getElementById('joinBtn');
    const roomIdInput = document.getElementById('roomIdinput');
    const roomDisplay = document.getElementById('roomId');
    const connectedDisplay = document.getElementById('connectedDevice');
    const fileInput = document.getElementById('fileInput');
    const sendBtn = document.getElementById('sendBtn');
    const sendProgressbar = document.getElementById('sendProgressbar');
    const receiveProgressbar = document.getElementById('receiveProgressbar');

    joinBtn.onclick = () => {
      if (joinBtn.textContent === 'Join Room') {
        roomId = roomIdInput.value;
        if (roomId.length !== 4) return alert("Room ID must be 4 digits");
        roomDisplay.textContent = roomId;
        socket.emit('join', roomId);
        joinBtn.textContent = 'Exit Room';
        joinBtn.classList.remove('bg-info');
        joinBtn.classList.add('bg-error');
      } else {
        location.reload();
      }
    };

    socket.on('device-count', count => {
      connectedDisplay.textContent = count;
    });

    socket.on('new-peer', async peerId => {
      const pc = createPeerConnection(peerId);
      const dc = pc.createDataChannel('file');
      setupSendChannel(dc, peerId);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('signal', { to: peerId, signal: { sdp: pc.localDescription } });
    });

    socket.on('signal', async ({ from, signal }) => {
      if (!peerConnections[from]) {
        peerConnections[from] = createPeerConnection(from);
      }
      const pc = peerConnections[from];
      if (signal.sdp) {
        await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        if (signal.sdp.type === 'offer') {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { to: from, signal: { sdp: pc.localDescription } });
        }
      } else if (signal.candidate) {
        await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
      }
    });

    function createPeerConnection(id) {
      const pc = new RTCPeerConnection();
      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit('signal', { to: id, signal: { candidate: e.candidate } });
        }
      };
      pc.ondatachannel = e => {
        const receiveChannel = e.channel;
        receiveFile(receiveChannel);
      };
      peerConnections[id] = pc;
      return pc;
    }

    function setupSendChannel(channel, peerId) {
      sendingChannel = channel;
      channel.onopen = () => {
        sendBtn.onclick = () => {
          const file = fileInput.files[0];
          if (!file) return alert("No file selected");
          sendingFile = file;
          sendFileInChunks(file, channel);
        };
      };
    }

    function sendFileInChunks(file, channel) {
      const chunkSize = 16 * 1024;
      let offset = 0;

      function readSlice(o) {
        const slice = file.slice(offset, o + chunkSize);
        fileReader = new FileReader();
        fileReader.onload = e => {
          channel.send(e.target.result);
          offset += e.target.result.byteLength;
          const percent = Math.floor((offset / file.size) * 100);
          sendProgressbar.style.width = percent + '%';
          if (offset < file.size) readSlice(offset);
        };
        fileReader.readAsArrayBuffer(slice);
      }

      channel.send(JSON.stringify({ name: file.name, size: file.size }));
      readSlice(0);
    }

    function receiveFile(channel) {
      let receivedBuffers = [];
      let fileMeta = null;
      let receivedSize = 0;

      channel.onmessage = e => {
        if (typeof e.data === 'string') {
          fileMeta = JSON.parse(e.data);
        } else {
          receivedBuffers.push(e.data);
          receivedSize += e.data.byteLength;
          const percent = Math.floor((receivedSize / fileMeta.size) * 100);
          receiveProgressbar.style.width = percent + '%';

          if (receivedSize >= fileMeta.size) {
            const blob = new Blob(receivedBuffers);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileMeta.name;
            a.click();
          }
        }
      };
    }
  </script>
</body>
</html>

 </body>
</html>