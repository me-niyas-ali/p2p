<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LAN File Sharing</title>
  <style>
   * {
    box-sizing: border-box;
   }

   body {
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f4f4f4;
   }

   h2,
   h3 {
    text-align: center;
   }

   .container {
    max-width: 500px;
    margin: auto;
    padding: 15px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
   }

   input[type="text"],
   input[type="file"] {
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    font-size: 16px;
    border-radius: 5px;
    border: 1px solid #ccc;
   }

   #roomDisplay,
   #connectedDisplay {
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
   }

   button {
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    font-size: 16px;
    border-radius: 5px;
    color: white;
    border: none;
    cursor: pointer;
   }

   .card {
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    background: #fff;
   }

   .progress {
    width: 100%;
    height: 15px;
    background: #eee;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
   }

   .bar {
    height: 100%;
    width: 10%;
    background: #4caf50;
    transition: width 0.3s;
   }

   #sendBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #4caf50;
   }

   #cancelBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #f44336;
   }

   #downloadBtn {
    display: block;
    margin-top: 10px;
    word-break: break-word;
    background-color: #2196f3;
   }

   .bg-success {
    background-color: #4caf50;
   }

   .bg-error {
    background-color: #f44336;
   }

   .bg-info {
    background-color: #2196f3;
   }

   .success {
    color: #4caf50;
   }

   .error {
    color: #f44336;
   }

   .info {
    color: #2196f3;
   }
  </style>
 </head>
 <body>
  <div class="container">
   <h2>P2P File Sharing</h2>
   <div> Room ID : <span id="roomId">----</span>
   </div>
   <div> Connected Devices : <span id="connectedDevice">0</span>
   </div>
   <input type="text" id="roomIdinput" placeholder="Enter Room Code (4-digit) to Host / Join" maxlength="4" />
   <button id="joinBtn" class="bg-info">Join Room</button>
   <input type="file" id="fileInput" />
   <button id="sendBtn">Send</button>
   <div id="sendFilesDisplay">
    <h3>Send Files</h3>
    <div class="card" id="sendCard" style="display: none;">
     <p>
      <strong id="sendFileName">file.name</strong>
     </p>
     <p id="sendFileSize">real-time.file.sizes</p>
     <div class="progress">
      <div class="bar" id="sendProgressbar"></div>
     </div>
     <button id="cancelSendBtn" class="bg-error">Cancel</button>
     <p class="success" id="sendSuccess" style="display: none;">File Sent</p>
     <p class="error" id="sendError" style="display: none;">Transfer Error</p>
     <p class="error" id="sendCancelled" style="display: none;">Transfer Cancelled</p>
    </div>
   </div>
   <div id="receivedFilesDisplay">
    <h3>Received Files</h3>
    <div class="card" id="receiveCard" style="display: none;">
     <p>
      <strong id="receiveFileName">file.name</strong>
     </p>
     <p id="receiveFileSize">real-time.file.sizes</p>
     <div class="progress">
      <div class="bar" id="receiveProgressbar"></div>
     </div>
     <button id="cancelReceiveBtn" class="bg-error">Cancel</button>
     <p class="success" id="receiveSuccess" style="display: none;">File Received</p>
     <p class="error" id="receiveError" style="display: none;">Transfer Error</p>
     <p class="error" id="receiveCancelled" style="display: none;">Transfer Cancelled</p>
     <button id="downloadBtn" style="display: none;">Download</button>
    </div>
   </div>
  </div>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
   const socket = io(); // assumes your server serves socket.io
   let peerConnection;
   let dataChannel;
   let fileReader;
   let fileToSend;
   let receivedBuffers = [];
   let fileMeta = {};
   let isHost = false;
   const joinBtn = document.getElementById('joinBtn');
   const roomIdInput = document.getElementById('roomIdinput');
   const roomDisplay = document.getElementById('roomId');
   const connectedDisplay = document.getElementById('connectedDevice');
   const sendBtn = document.getElementById('sendBtn');
   const fileInput = document.getElementById('fileInput');
   const sendCard = document.getElementById('sendCard');
   const sendFileName = document.getElementById('sendFileName');
   const sendFileSize = document.getElementById('sendFileSize');
   const sendProgress = document.getElementById('sendProgressbar');
   const cancelSendBtn = document.getElementById('cancelSendBtn');
   const receiveCard = document.getElementById('receiveCard');
   const receiveFileName = document.getElementById('receiveFileName');
   const receiveFileSize = document.getElementById('receiveFileSize');
   const receiveProgress = document.getElementById('receiveProgressbar');
   const cancelReceiveBtn = document.getElementById('cancelReceiveBtn');
   const downloadBtn = document.getElementById('downloadBtn');
   // Toggle join/leave
   joinBtn.addEventListener('click', () => {
    const roomId = roomIdInput.value.trim();
    if (joinBtn.textContent === 'Join Room') {
     if (!/^\d{4}$/.test(roomId)) return alert('Enter 4-digit room code.');
     socket.emit('join-room', roomId);
     joinBtn.textContent = 'Exit Room';
     joinBtn.className = 'bg-error';
     roomDisplay.textContent = roomId;
    } else {
     socket.emit('leave-room');
     resetState();
    }
   });

   function resetState() {
    peerConnection?.close();
    peerConnection = null;
    dataChannel = null;
    roomDisplay.textContent = '----';
    connectedDisplay.textContent = '0';
    joinBtn.textContent = 'Join Room';
    joinBtn.className = 'bg-info';
    sendCard.style.display = 'none';
    receiveCard.style.display = 'none';
   }
   // Setup connection
   socket.on('init-host', () => {
    isHost = true;
    setupPeer(true);
   });
   socket.on('init-guest', () => {
    isHost = false;
    setupPeer(false);
   });
   socket.on('signal', ({
    desc,
    candidate
   }) => {
    if (desc) peerConnection.setRemoteDescription(desc).then(() => {
     if (desc.type === 'offer') {
      peerConnection.createAnswer().then(answer => {
       peerConnection.setLocalDescription(answer);
       socket.emit('signal', {
        desc: answer
       });
      });
     }
    });
    if (candidate) peerConnection.addIceCandidate(candidate);
   });

   function setupPeer(isInitiator) {
    peerConnection = new RTCPeerConnection();
    peerConnection.onicecandidate = ({
     candidate
    }) => {
     if (candidate) socket.emit('signal', {
      candidate
     });
    };
    if (isInitiator) {
     dataChannel = peerConnection.createDataChannel('file');
     setupDataChannel();
     peerConnection.createOffer().then(offer => {
      peerConnection.setLocalDescription(offer);
      socket.emit('signal', {
       desc: offer
      });
     });
    } else {
     peerConnection.ondatachannel = (event) => {
      dataChannel = event.channel;
      setupDataChannel();
     };
    }
    connectedDisplay.textContent = '2';
   }

   function setupDataChannel() {
    dataChannel.binaryType = 'arraybuffer';
    dataChannel.onopen = () => console.log('Data channel open');
    dataChannel.onclose = () => console.log('Data channel closed');
    dataChannel.onmessage = (e) => {
     if (typeof e.data === 'string') {
      const msg = JSON.parse(e.data);
      if (msg.type === 'meta') {
       fileMeta = msg;
       receivedBuffers = [];
       receiveCard.style.display = 'block';
       receiveFileName.textContent = msg.name;
       receiveFileSize.textContent = `0 / ${formatBytes(msg.size)}`;
      } else if (msg.type === 'cancel') {
       receiveCancelled.style.display = 'block';
       receiveProgress.style.width = '0%';
      }
     } else {
      receivedBuffers.push(e.data);
      const receivedSize = receivedBuffers.reduce((acc, chunk) => acc + chunk.byteLength, 0);
      receiveProgress.style.width = `${(receivedSize / fileMeta.size) * 100}%`;
      receiveFileSize.textContent = `${formatBytes(receivedSize)} / ${formatBytes(fileMeta.size)}`;
      if (receivedSize >= fileMeta.size) {
       const blob = new Blob(receivedBuffers);
       const url = URL.createObjectURL(blob);
       downloadBtn.href = url;
       downloadBtn.download = fileMeta.name;
       downloadBtn.style.display = 'block';
       receiveSuccess.style.display = 'block';
      }
     }
    };
   }
   // Send File
   sendBtn.addEventListener('click', () => {
    if (!dataChannel || dataChannel.readyState !== 'open') return alert('Not connected.');
    const file = fileInput.files[0];
    if (!file) return alert('No file selected.');
    fileToSend = file;
    sendCard.style.display = 'block';
    sendFileName.textContent = file.name;
    sendFileSize.textContent = `0 / ${formatBytes(file.size)}`;
    sendProgress.style.width = '0%';
    const meta = JSON.stringify({
     type: 'meta',
     name: file.name,
     size: file.size
    });
    dataChannel.send(meta);
    const chunkSize = 16 * 1024;
    let offset = 0;
    const reader = new FileReader();
    reader.onload = (e) => {
     dataChannel.send(e.target.result);
     offset += e.target.result.byteLength;
     sendProgress.style.width = `${(offset / file.size) * 100}%`;
     sendFileSize.textContent = `${formatBytes(offset)} / ${formatBytes(file.size)}`;
     if (offset < file.size) {
      readSlice(offset);
     } else {
      sendSuccess.style.display = 'block';
     }
    };
    const readSlice = (o) => {
     const slice = file.slice(o, o + chunkSize);
     reader.readAsArrayBuffer(slice);
    };
    readSlice(0);
   });
   // Cancel Buttons
   cancelSendBtn.onclick = () => {
    if (dataChannel?.readyState === 'open') {
     dataChannel.send(JSON.stringify({
      type: 'cancel'
     }));
     sendCancelled.style.display = 'block';
     sendProgress.style.width = '0%';
    }
   };
   cancelReceiveBtn.onclick = () => {
    receiveCancelled.style.display = 'block';
    receiveProgress.style.width = '0%';
   };
   // Utils
   function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${sizes[i]}`;
   }
  </script>
 </body>
</html>
