<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>P2P File Share</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 600px;
      margin: auto;
      padding: 1rem;
    }
    input, button {
      font-size: 1rem;
      margin: 0.3rem 0;
    }
    .card {
      border: 1px solid #ccc;
      padding: 1rem;
      margin-top: 1rem;
      border-radius: 5px;
    }
    .progress {
      height: 10px;
      background: #eee;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 0.5rem;
    }
    .bar {
      height: 100%;
      width: 0%;
      background: green;
      transition: width 0.2s;
    }
    .download-link {
      display: inline-block;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <h2>üåê P2P File Share</h2>
  <input type="text" id="roomInput" placeholder="Enter 6-digit Room ID" maxlength="6" />
  <button id="roomButton" onclick="toggleRoom()">Join Room</button>
  <p id="roomDisplay"></p>
  <p id="connectedDisplay">Connected: 0</p>

  <input type="file" id="fileInput" />
  <button onclick="sendFile()">Send File</button>
  <div id="fileCardContainer"></div>
  <div id="receivedFiles"></div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    const socket = io();
    let room = null;
    let isHost = false;
    let file = null;
    let peers = {};
    let dataChannels = {};
    let localConnection = {};
    let receivedBuffers = {};

    const configuration = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function formatBytes(bytes) {
      const sizes = ['B','KB','MB','GB','TB'];
      if (bytes === 0) return '0 B';
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      return (bytes / Math.pow(1024, i)).toFixed(2).replace(/\.00$/, '') + ' ' + sizes[i];
    }

    function toggleRoom() {
      const code = document.getElementById('roomInput').value.trim();
      if (!room && code.length === 6) {
        room = code;
        document.getElementById('roomDisplay').innerText = 'Room: ' + room;
        document.getElementById('roomButton').innerText = 'Exit Room';
        socket.emit('join-room', room);
      } else {
        Object.values(dataChannels).forEach(dc => dc.close());
        Object.values(localConnection).forEach(pc => pc.close());
        peers = {};
        dataChannels = {};
        localConnection = {};
        socket.disconnect();
        location.reload();
      }
    }

    socket.on('connect', () => {
      console.log('Socket connected');
    });

    socket.on('user-joined', userId => {
      createPeerConnection(userId, true);
      updateConnectedCount();
    });

    socket.on('user-left', () => {
      updateConnectedCount();
    });

    socket.on('signal', async ({ from, data }) => {
      if (!localConnection[from]) {
        createPeerConnection(from, false);
      }

      if (data.type === 'offer') {
        await localConnection[from].setRemoteDescription(new RTCSessionDescription(data));
        const answer = await localConnection[from].createAnswer();
        await localConnection[from].setLocalDescription(answer);
        socket.emit('signal', { room, target: from, data: answer });

      } else if (data.type === 'answer') {
        await localConnection[from].setRemoteDescription(new RTCSessionDescription(data));
      } else if (data.candidate) {
        try {
          await localConnection[from].addIceCandidate(new RTCIceCandidate(data));
        } catch (err) {
          console.error('ICE error', err);
        }
      }
    });

    function createPeerConnection(peerId, initiator) {
      const pc = new RTCPeerConnection(configuration);
      localConnection[peerId] = pc;

      pc.onicecandidate = event => {
        if (event.candidate) {
          socket.emit('signal', { room, target: peerId, data: event.candidate });
        }
      };

      if (initiator) {
        const dc = pc.createDataChannel("file");
        setupDataChannel(peerId, dc);
        dataChannels[peerId] = dc;

        pc.createOffer()
          .then(offer => pc.setLocalDescription(offer))
          .then(() => {
            socket.emit('signal', { room, target: peerId, data: pc.localDescription });
          });
      } else {
        pc.ondatachannel = event => {
          setupDataChannel(peerId, event.channel);
        };
      }

      pc.onconnectionstatechange = () => {
        updateConnectedCount();
      };
    }

    function setupDataChannel(peerId, dc) {
      dc.binaryType = 'arraybuffer';

      dc.onmessage = event => {
        if (!receivedBuffers[peerId]) receivedBuffers[peerId] = [];
        const data = event.data;

        if (typeof data === 'string' && data.startsWith('FILE_META:')) {
          const meta = JSON.parse(data.replace('FILE_META:', ''));
          receivedBuffers[peerId] = { ...meta, chunks: [], received: 0 };

          const id = meta.name.replace(/\W/g, '');
          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <p><strong>${meta.name}</strong></p>
            <p>${formatBytes(meta.size)}</p>
            <div class="progress"><div class="bar" id="recv-${id}"></div></div>
          `;
          document.getElementById("receivedFiles").appendChild(card);
          receivedBuffers[peerId].barId = `recv-${id}`;

        } else if (data instanceof ArrayBuffer) {
          const buffer = receivedBuffers[peerId];
          if (!buffer) return;

          buffer.chunks.push(data);
          buffer.received += data.byteLength;

          const bar = document.getElementById(buffer.barId);
          if (bar) bar.style.width = `${(buffer.received / buffer.size) * 100}%`;

          if (buffer.received >= buffer.size) {
            const blob = new Blob(buffer.chunks);
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = buffer.name;
            link.textContent = `‚¨áÔ∏è Download (${formatBytes(buffer.size)})`;
            link.className = 'download-link';

            const card = bar.closest(".card");
            bar.style.display = "none";
            const msg = document.createElement("p");
            msg.textContent = "File Received";
            msg.style.color = "blue";
            card.appendChild(msg);
            card.appendChild(link);

            delete receivedBuffers[peerId];
          }
        }
      };
    }

    function updateConnectedCount() {
      const count = Object.keys(localConnection).length;
      document.getElementById('connectedDisplay').innerText = `Connected: ${count}`;
    }

    document.getElementById('fileInput').addEventListener('change', e => {
      file = e.target.files[0];
      if (file) {
        document.getElementById("fileCardContainer").innerHTML = `
          <div class="card">
            <p><strong>${file.name}</strong></p>
            <p>${formatBytes(file.size)}</p>
            <div class="progress"><div id="progressBar" class="bar"></div></div>
          </div>
        `;
      }
    });

    function sendFile() {
      if (!file || Object.keys(dataChannels).length === 0) return;
      const meta = JSON.stringify({ name: file.name, size: file.size });

      Object.values(dataChannels).forEach(dc => dc.send("FILE_META:" + meta));

      const chunkSize = 64 * 1024;
      let offset = 0;

      const reader = new FileReader();
      reader.onload = e => {
        const buffer = e.target.result;
        Object.values(dataChannels).forEach(dc => dc.send(buffer));
        offset += chunkSize;

        document.getElementById("progressBar").style.width = `${(offset / file.size) * 100}%`;
        if (offset < file.size) {
          readSlice();
        } else {
          const msg = document.createElement("p");
          msg.textContent = "File Sent";
          msg.style.color = "green";
          document.querySelector("#fileCardContainer .card").appendChild(msg);
        }
      };

      function readSlice() {
        const slice = file.slice(offset, offset + chunkSize);
        reader.readAsArrayBuffer(slice);
      }
      readSlice();
    }
  </script>
</body>
</html>
