<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC File Sharing</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background-color: #f0f0f0;
    }
    h2 {
      margin-top: 0;
    }
    #room-controls, #file-controls, #transfer-status {
      margin-bottom: 20px;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
    }
    input[type="text"], input[type="file"] {
      padding: 8px;
      margin-right: 10px;
    }
    button {
      padding: 8px 16px;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    .hidden {
      display: none;
    }
    #notifications {
      margin-top: 10px;
      color: green;
    }
  </style>
</head>
<body>
  <h2>WebRTC File Sharing</h2>

  <div id="room-controls">
    <input type="text" id="room-id" placeholder="Enter 4-digit Room ID" maxlength="4" />
    <button id="join-btn">Join Room</button>
    <p id="connection-status">Not connected</p>
  </div>

  <div id="file-controls" class="hidden">
    <input type="file" id="file-input" />
    <button id="send-btn">Send</button>
    <p id="file-info"></p>
  </div>

  <div id="transfer-status" class="hidden">
    <h3>Transfer Progress</h3>
    <p>Sending: <progress id="send-progress" value="0" max="100"></progress></p>
    <p>Receiving: <progress id="receive-progress" value="0" max="100"></progress></p>
    <button id="cancel-btn">Cancel Transfer</button>
  </div>

  <div id="notifications"></div>

  <script>
    const SIGNALING_SERVER_URL = 'wss://your-signaling-server.com'; // Replace with your signaling server URL
    const roomIdInput = document.getElementById('room-id');
    const joinBtn = document.getElementById('join-btn');
    const connectionStatus = document.getElementById('connection-status');
    const fileControls = document.getElementById('file-controls');
    const fileInput = document.getElementById('file-input');
    const sendBtn = document.getElementById('send-btn');
    const fileInfo = document.getElementById('file-info');
    const transferStatus = document.getElementById('transfer-status');
    const sendProgress = document.getElementById('send-progress');
    const receiveProgress = document.getElementById('receive-progress');
    const cancelBtn = document.getElementById('cancel-btn');
    const notifications = document.getElementById('notifications');

    let socket;
    let pc;
    let dataChannel;
    let fileReader;
    let file;
    let receivedBuffers = [];

    joinBtn.addEventListener('click', () => {
      const roomId = roomIdInput.value;
      if (roomId.length !== 4) {
        alert('Please enter a 4-digit Room ID.');
        return;
      }
      joinRoom(roomId);
    });

    sendBtn.addEventListener('click', () => {
      if (fileInput.files.length === 0) {
        alert('Please select a file.');
        return;
      }
      file = fileInput.files[0];
      fileInfo.textContent = `File: ${file.name} (${file.size} bytes)`;
      sendFile();
    });

    cancelBtn.addEventListener('click', () => {
      if (dataChannel) {
        dataChannel.close();
      }
      if (pc) {
        pc.close();
      }
      connectionStatus.textContent = 'Transfer cancelled.';
      transferStatus.classList.add('hidden');
    });

    function joinRoom(roomId) {
      socket = new WebSocket(SIGNALING_SERVER_URL);

      socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'join', room: roomId }));
      };

      socket.onmessage = async (message) => {
        const data = JSON.parse(message.data);
        switch (data.type) {
          case 'joined':
            createPeerConnection();
            if (data.initiator) {
              dataChannel = pc.createDataChannel('file');
              setupDataChannel();
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              socket.send(JSON.stringify({ type: 'offer', offer }));
            }
            connectionStatus.textContent = `Connected to Room ${roomId}`;
            fileControls.classList.remove('hidden');
            break;
          case 'offer':
            await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: 'answer', answer }));
            break;
          case 'answer':
            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            break;
          case 'candidate':
            if (data.candidate) {
              await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
            break;
        }
      };
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection();

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
        }
      };

      pc.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel();
      };
    }

    function setupDataChannel() {
      dataChannel.onopen = () => {
        console.log('Data channel opened');
      };

      dataChannel.onmessage = (event) => {
        receivedBuffers.push(event.data);
        const receivedSize = receivedBuffers.reduce((acc, curr) => acc + curr.byteLength, 0);
        receiveProgress.value = (receivedSize / file.size) * 100;

        if (receivedSize === file.size) {
          const receivedBlob = new Blob(receivedBuffers);
          const downloadLink = document.createElement('a');
          downloadLink.href = URL.createObjectURL(receivedBlob);
          downloadLink.download = file.name;
          downloadLink.textContent = 'Download Received File';
          notifications.appendChild(downloadLink);
          notifications.appendChild(document.createElement('br'));
          transferStatus.classList.add('hidden');
          receivedBuffers = [];
        }
      };
    }

    function sendFile() {
      transferStatus.classList.remove('hidden');
      const chunkSize = 16384;
      let offset = 0;

      fileReader = new FileReader();

      fileReader.onload = (e) => {
        dataChannel.send(e.target.result);
        offset += e.target.result.byteLength;
        sendProgress.value = (offset / file.size) * 100;

        if (offset < file.size) {
          readSlice(offset);
        } else {
          notifications.textContent = 'File sent successfully.';
        }
      };

      const readSlice = (o) => {
        const slice = file.slice(offset, o + chunkSize);
        fileReader.readAsArrayBuffer(slice);
      };

      readSlice(0);
    }
  </script>
</body>
</html>
