<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>P2P File Share</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f2f2f2; margin: 0; padding: 10px; }
        .card { background: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 20px; margin: 10px auto; max-width: 600px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h2 { margin-top: 0; }
        input, button { padding: 8px; margin: 5px 0; }
        button { cursor: pointer; }
        #file-input { width: 100%; }
        #send-button { margin-top: 10px; }
        .transfer-card { margin: 10px 0; }
        .progress-container { background: #eee; border-radius: 4px; overflow: hidden; width: 100%; height: 20px; }
        .progress-bar { background: #4caf50; height: 100%; width: 0%; }
        #toast-container { position: fixed; top: 10px; right: 10px; z-index: 1000; }
        .toast { background: #333; color: #fff; padding: 10px; margin-top: 5px; border-radius: 4px; opacity: 0.9; }
        .modal { display: none; position: fixed; top: 0; left: 0; width:100%; height:100%; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background: #fff; padding: 20px; border-radius: 6px; text-align: center; }
        .modal button { margin: 10px; }
        @media (max-width: 600px) {
            .card { width: 90%; }
        }
    </style>
</head>
<body>
    <!-- Room Join Card -->
    <div class="card" id="room-card">
        <h2>Join Room</h2>
        <input id="room-id-input" type="text" placeholder="Enter 4-digit Room ID" maxlength="4" pattern="\d*">
        <button id="join-button">Join Room</button>
        <div id="room-info" style="margin-top: 10px;">
            <strong>Room:</strong> <span id="current-room">None</span><br>
            <strong>Peers:</strong> <span id="peer-count">0</span>
        </div>
    </div>

    <!-- File Transfer Card (hidden until joined) -->
    <div class="card" id="file-card" style="display: none;">
        <h2>File Transfer</h2>
        <input type="file" id="file-input"><br>
        <div id="file-info"></div>
        <button id="send-button" disabled>Send</button>
    </div>

    <!-- Container for dynamic transfer cards -->
    <div id="transfer-container"></div>

    <!-- Toast notifications -->
    <div id="toast-container"></div>

    <!-- Modal confirmation dialog -->
    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <p id="modal-text">Peer wants to send file</p>
            <button id="accept-file-button">Accept</button>
            <button id="reject-file-button">Reject</button>
        </div>
    </div>

    <!-- Socket.IO library -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
        const socket = io('https://p2p-share-7wvh.onrender.com'); // replace with your deployed backend URL

        let roomId = null;
        let peers = new Set();
        const peerConnections = {};   // RTCPeerConnection objects keyed by peer ID
        const dataChannels = {};      // RTCDataChannel objects keyed by peer ID
        let selectedFile = null;
        let acceptedPeers = [];
        let sendInProgress = false;
        const chunkSize = 16 * 1024; // 16KB chunks

        // UI elements
        const joinBtn = document.getElementById('join-button');
        const roomInput = document.getElementById('room-id-input');
        const currentRoomSpan = document.getElementById('current-room');
        const peerCountSpan = document.getElementById('peer-count');
        const fileCard = document.getElementById('file-card');
        const fileInput = document.getElementById('file-input');
        const sendButton = document.getElementById('send-button');
        const fileInfo = document.getElementById('file-info');
        const transferContainer = document.getElementById('transfer-container');
        const toastContainer = document.getElementById('toast-container');
        const modal = document.getElementById('confirm-modal');
        const modalText = document.getElementById('modal-text');
        const acceptBtn = document.getElementById('accept-file-button');
        const rejectBtn = document.getElementById('reject-file-button');

        // Show a toast message
        function showToast(msg) {
            const div = document.createElement('div');
            div.className = 'toast';
            div.textContent = msg;
            toastContainer.appendChild(div);
            setTimeout(() => div.remove(), 3000);
        }

        // Show confirmation modal
        function showConfirmation(text, onAccept, onReject) {
            modalText.textContent = text;
            modal.style.display = 'flex';
            acceptBtn.onclick = () => { modal.style.display = 'none'; onAccept(); };
            rejectBtn.onclick = () => { modal.style.display = 'none'; onReject(); };
        }

        // Join or leave room button logic
        joinBtn.onclick = () => {
            if (!roomId) {
                // Attempt to join
                const id = roomInput.value.trim();
                if (!/^\d{4}$/.test(id)) {
                    alert('Enter a valid 4-digit Room ID');
                    return;
                }
                roomId = id;
                socket.emit('join-room', { roomId });
            } else {
                // Leave the room
                socket.emit('leave-room', { roomId });
                cleanupRoom();
            }
        };

        // Clean up after leaving
        function cleanupRoom() {
            peers.forEach(id => {
                if (peerConnections[id]) peerConnections[id].close();
            });
            Object.keys(peerConnections).forEach(id => delete peerConnections[id]);
            Object.keys(dataChannels).forEach(id => delete dataChannels[id]);
            peers.clear();
            selectedFile = null;
            acceptedPeers = [];
            sendInProgress = false;
            fileInput.value = null;
            fileInfo.textContent = '';
            currentRoomSpan.textContent = 'None';
            peerCountSpan.textContent = '0';
            fileCard.style.display = 'none';
            sendButton.disabled = true;
            joinBtn.textContent = 'Join Room';
            roomId = null;
            transferContainer.innerHTML = '';
            showToast('Left the room');
        }

        // Socket.IO event handlers
        socket.on('room-created', () => {
            // First user (host) created the room
            fileCard.style.display = 'block';
            currentRoomSpan.textContent = roomId;
            joinBtn.textContent = 'Exit Room';
            showToast('Room created. You are host.');
        });
        socket.on('all-users', (existingPeers) => {
            // Joined existing room, get list of other peers
            fileCard.style.display = 'block';
            currentRoomSpan.textContent = roomId;
            joinBtn.textContent = 'Exit Room';
            showToast('Joined room ' + roomId);
            existingPeers.forEach(peerId => {
                createPeerConnection(peerId, true);
                peers.add(peerId);
            });
            peerCountSpan.textContent = peers.size;
        });
        socket.on('user-joined', (peerId) => {
            // New peer joined room
            createPeerConnection(peerId, false);
            peers.add(peerId);
            peerCountSpan.textContent = peers.size;
            showToast('Peer joined: ' + peerId);
        });
        socket.on('user-left', (peerId) => {
            // A peer left
            if (peerConnections[peerId]) peerConnections[peerId].close();
            delete peerConnections[peerId];
            peers.delete(peerId);
            delete dataChannels[peerId];
            peerCountSpan.textContent = peers.size;
            showToast('Peer left: ' + peerId);
        });

        // Relay of WebRTC signaling data (offer/answer/ICE) via Socket.IO
        socket.on('signal', async (data) => {
            const { from, type, sdp, candidate } = data;
            let pc = peerConnections[from];
            if (!pc) {
                // Create connection if not existing
                createPeerConnection(from, false);
                pc = peerConnections[from];
                peers.add(from);
                peerCountSpan.textContent = peers.size;
            }
            if (type === 'offer') {
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('signal', { to: from, type: 'answer', sdp: pc.localDescription });
            } else if (type === 'answer') {
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            } else if (type === 'ice') {
                if (candidate) {
                    try { await pc.addIceCandidate(candidate); }
                    catch (e) { console.error('ICE candidate failed', e); }
                }
            }
        });

        // Create an RTCPeerConnection and (if initiator) a DataChannel
        function createPeerConnection(peerId, initiator) {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            peerConnections[peerId] = pc;

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('signal', { to: peerId, type: 'ice', candidate: event.candidate });
                }
            };

            if (initiator) {
                // Outgoing connection: create data channel and offer
                const dc = pc.createDataChannel('fileChannel');
                setupDataChannel(peerId, dc);
                pc.onnegotiationneeded = async () => {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socket.emit('signal', { to: peerId, type: 'offer', sdp: pc.localDescription });
                };
            } else {
                // Incoming connection: wait for data channel
                pc.ondatachannel = (event) => {
                    setupDataChannel(peerId, event.channel);
                };
            }
        }

        // Set up RTCDataChannel event handlers
        function setupDataChannel(peerId, dc) {
            dataChannels[peerId] = dc;
            dc.binaryType = 'arraybuffer';
            dc.onopen = () => { console.log('Data channel open with', peerId); };
            dc.onmessage = (event) => { onDataChannelMessage(peerId, event.data); };
            dc.onclose = () => { console.log('Data channel closed with', peerId); };
        }

        // Handle file input selection
        fileInput.onchange = () => {
            const file = fileInput.files[0];
            if (file) {
                selectedFile = file;
                const sizeMB = (file.size/(1024*1024)).toFixed(2);
                const sizeText = file.size > 1024*1024 ? `${sizeMB} MB` : `${(file.size/1024).toFixed(2)} KB`;
                fileInfo.textContent = `Selected: ${file.name} (${sizeText})`;
                sendButton.disabled = false;
            }
        };

        // Send file metadata to peers
        sendButton.onclick = () => {
            if (!selectedFile) return;
            acceptedPeers = [];
            sendInProgress = false;
            const name = selectedFile.name, size = selectedFile.size;
            peers.forEach(peerId => {
                // Offer file to each peer
                const message = { type: 'file-meta', name, size };
                dataChannels[peerId].send(JSON.stringify(message));
                createTransferCard('sending', peerId, name, size);
            });
        };

        // Handle incoming data on data channel (string or binary)
        function onDataChannelMessage(peerId, data) {
            if (typeof data === 'string') {
                const msg = JSON.parse(data);
                if (msg.type === 'file-meta') {
                    // A peer offers a file
                    const meta = msg;
                    showConfirmation(
                        `Receive file "${meta.name}" (${(meta.size/1024).toFixed(1)} KB) from peer?`,
                        () => {
                            // Accept: notify sender and prepare UI
                            dataChannels[peerId].send(JSON.stringify({ type: 'file-accept' }));
                            createTransferCard('receiving', peerId, meta.name, meta.size);
                            receiveBuffers[peerId] = { data: [], received: 0, meta: meta };
                        },
                        () => {
                            // Reject
                            dataChannels[peerId].send(JSON.stringify({ type: 'file-reject' }));
                        }
                    );
                } else if (msg.type === 'file-accept') {
                    // Peer accepted our file offer
                    if (!acceptedPeers.includes(peerId)) acceptedPeers.push(peerId);
                    if (!sendInProgress) {
                        sendInProgress = true;
                        startFileTransfer();
                    }
                } else if (msg.type === 'file-reject') {
                    // Peer rejected
                    showToast('Peer ' + peerId + ' rejected the file.');
                    removeTransferCard('sending', peerId);
                } else if (msg.type === 'file-cancel') {
                    // Peer canceled
                    showToast('Peer ' + peerId + ' cancelled the transfer.');
                    removeTransferCard('receiving', peerId);
                }
            } else {
                // Received a file chunk (binary data)
                receiveFileChunk(peerId, data);
            }
        }

        // Create a file transfer card (sending or receiving) with progress bar
        function createTransferCard(mode, peerId, name, size) {
            const card = document.createElement('div');
            card.className = 'card transfer-card';
            card.id = `${mode}-card-${peerId}`;
            let html = `<h3>${mode === 'sending' ? 'Sending to' : 'Receiving from'} ${peerId}</h3>`;
            html += `<div>File: ${name}</div>`;
            const sizeText = size > 1024*1024 ? `${(size/(1024*1024)).toFixed(2)} MB` : `${(size/1024).toFixed(2)} KB`;
            html += `<div>Size: ${sizeText}</div>`;
            html += `<div class="progress-container"><div class="progress-bar" id="${mode}-bar-${peerId}"></div></div>`;
            html += `<div id="${mode}-percent-${peerId}">0%</div>`;
            if (mode === 'receiving') {
                html += `<button id="download-${peerId}" disabled>Download</button>`;
            }
            html += `<button id="cancel-${mode}-${peerId}">Cancel</button>`;
            card.innerHTML = html;
            transferContainer.appendChild(card);

            // Cancel button
            const cancelBtn = document.getElementById(`cancel-${mode}-${peerId}`);
            cancelBtn.onclick = () => {
                if (mode === 'sending') {
                    acceptedPeers = acceptedPeers.filter(id => id !== peerId);
                    dataChannels[peerId].send(JSON.stringify({ type: 'file-cancel' }));
                    removeTransferCard('sending', peerId);
                } else {
                    dataChannels[peerId].send(JSON.stringify({ type: 'file-cancel' }));
                    removeTransferCard('receiving', peerId);
                }
            };
        }

        function removeTransferCard(mode, peerId) {
            const card = document.getElementById(`${mode}-card-${peerId}`);
            if (card) card.remove();
        }

        // Read file in chunks and send to accepted peers
        async function startFileTransfer() {
            const file = selectedFile;
            let offset = 0;
            const size = file.size;
            while (offset < size && acceptedPeers.length > 0) {
                const chunk = file.slice(offset, offset + chunkSize);
                const buffer = await chunk.arrayBuffer();
                acceptedPeers.forEach(peerId => {
                    if (dataChannels[peerId].readyState === 'open') {
                        dataChannels[peerId].send(buffer);
                    }
                });
                offset += buffer.byteLength;
                const percent = Math.round((offset/size)*100);
                acceptedPeers.forEach(peerId => {
                    const bar = document.getElementById(`sending-bar-${peerId}`);
                    const pct = document.getElementById(`sending-percent-${peerId}`);
                    if (bar) bar.style.width = percent + '%';
                    if (pct) pct.textContent = percent + '%';
                });
            }
            // Done
            acceptedPeers.forEach(peerId => {
                showToast('File sent to ' + peerId);
                removeTransferCard('sending', peerId);
            });
        }

        // Buffer for incoming file chunks
        const receiveBuffers = {};

        function receiveFileChunk(peerId, chunk) {
            if (!receiveBuffers[peerId]) return;
            receiveBuffers[peerId].data.push(chunk);
            receiveBuffers[peerId].received += chunk.byteLength;
            const { meta, received } = receiveBuffers[peerId];
            const percent = Math.round((received/meta.size)*100);
            const bar = document.getElementById(`receiving-bar-${peerId}`);
            const pct = document.getElementById(`receiving-percent-${peerId}`);
            if (bar) bar.style.width = percent + '%';
            if (pct) pct.textContent = percent + '%';
            if (received === meta.size) {
                // File fully received
                const blob = new Blob(receiveBuffers[peerId].data);
                const downloadBtn = document.getElementById(`download-${peerId}`);
                downloadBtn.disabled = false;
                downloadBtn.onclick = () => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = meta.name;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                };
                showToast('File received from ' + peerId);
                delete receiveBuffers[peerId];
            }
        }
    </script>
</body>
</html>
